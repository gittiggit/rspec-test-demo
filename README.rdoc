== README

01. Setup rspec and capybra

group :development, :test do
  gem "rspec-rails", "3.2.3"   #latest 3.4.0
end

group :test do
  gem "capybara", "2.6.4"   #latest 2.6.0
end

** capybra is only for test

=> bundle install

=> rails g rspec:install
It will create spec_helper.rb and rails_helper.rb

=============================================================================

Step 2:

Blog App
-Articles
  -ID
  -Title
  -Body

- Users
  - ID
  - Email
  - Password

- Comments
  - ID
  - Body
  - User_ID
  -Article_ID

To test the app, first we have to write our features test first, then we will build the features so that it
can pass the feature test

creating a new file
spec/features/creating_article_spec.rb and withing this at the top
require "rails_helper"
To write a feature test, there is specific syntax to follow

require "rails_helper"

RSpec.feature "Creating Articles" do
  scenario "A user creates a new article" do
    visit "/"

    click_link "New Article"

    fill_in "Title", with: "Creating first article"
    fill_in "Body", with: "Lorem Ispum"
    click_button "Create Article"

    expect(page).to have_content("Article has been created")
    expect(page.current_path).to eq(articles_path)
  end
end

To run this test

rspec spec/features/creating_article_spec.rb

It will shows an error like as follows
Failure/Error: visit "/"
     ActionController::RoutingError:
       No route matches [GET] "/"

visit "/"   # It expects to have a root route in the app

** To fix this we have to define a root route
root "articles#index"

Now it will show the error like as
 Failure/Error: visit "/"
     ActionController::RoutingError:
       uninitialized constant ArticlesController

** To fix this we need to create ArticlesController
rails g controller Articles index
Lets run the test again and it will shows the following error
Failure/Error: click_link "New Article"
     Capybara::ElementNotFound:
       Unable to find link "New Article"

** To fix this, we are going to create this link now on the app/views/articles/index.html.erb
<%= link_to "New Article", new_article_path %>

Lets run the test

Failure/Error: visit "/"
     ActionView::Template::Error:
       undefined local variable or method `new_article_path'

** Now Take this assignments: The methods I have used within the spec/features/creating_article_spec.rb file
   find which method belong to rspec and which method belong to capybara??

Context is an alias for describe, and so functionally equivalent. You can use them interchangeably, the only
difference is in how your spec file reads (there's no difference in test output for example). The Rspec book says:

Feature and scenario are a part of Capybara, and not rspec, and are meant to be used for acceptance tests.

Feature is equivalent to describe / context, and scenario equivalent to it / example.

If you're writing acceptance tests with Capybara, use the feature / scenario syntax, if not use describe / it syntax.

** After the google search, I found
feature, fill_in, click_button, scenario, visit, expect(page).to all are methods from capybara

Please follow the link for more information
https://github.com/jnicklas/capybara


==========================================================================================

Step 3: Setup bootstrap, add navigation and messages

gem "bootstrap-sass"
gem "autoprefixer-rails"

=> bundle install

** Create a file app/assets/custom.css.scss, at the top of it, include the following codes
@import "bootstrap-sprockets"
@import "bootstrap"

At the assets/javascripts/application.js
include the  //= require bootstrap-sprockets
//= require jquery
//= require jquery_ujs
//= require bootstrap-sprockets
//= require turbolinks
//= require_tree .


In the application.html.erb

<body>
<nav class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container-fluid">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <%= link_to "RSpec Test App", root_path, class: "navbar-brand" %>
    </div>
    <div class="navbar-collapse collapse" id="bs-example-navbar-collapse-1">
      <ul class="nav navbar-nav">
        <li class="active"><%= link_to "Authors", "#" %></li>
      </ul>
    </div>
  </div>
</nav>
<div class="container">
  <% flash.each do |key, value| %>
    <div class='alert alert-<%= "#{key}" %>'>
      <a href="#" class="close" data-dismiss="alert">&#215;</a>
      <%= content_tag :div, value, id: "flash_#{key}" if value.is_a?(String) %>
    </div>
  <% end %>
  <div class="row">
    <div class="col-md-10 col-md-offset-1">
      <div class="col-md-8">
        <%= yield %>
      </div>
      <div class="col-md-8">
        <%= yield :sidebar %>
      </div>
    </div>
  </div>
</div>
</body>

======================================================================================================


Step 4:
       a. Create a route for the new_article_path
       b. run the tast again, it will shows the error like as
        Failure/Error: click_link "New Article"
            AbstractController::ActionNotFound:
              The action 'new' could not be found for ArticlesController


       c. To fix this, create a new action in the article controller, run the test
         def new
             @article = Article.new
         end


       Failure/Error: click_link "New Article"
           NameError:
             uninitialized constant ArticlesController::Article

       d. It means the model Article is not created
          => rails g model Article title:string body:text
          => rake db:migrate
          run the test
          Failure/Error: click_link "New Article"
          ActionView::MissingTemplate:
          Missing template articles/new, application/new with {:locale=>[:en], :formats=>[:html], :variants=>[],
           :handlers=>[:erb, :builder, :raw, :ruby, :coffee, :jbuilder]}. Searched in:


       d. Now create articles/new.html.erb, run the test
           Failure/Error: fill_in "Title", with: "Creating first article"
           Capybara::ElementNotFound:
           Unable to find field "Title

       e. Now we will use the following codes to test the new.html.erb


       =================================================================================================
       <h3 class='text-center'> Adding New Article</h3>
       <div class='row'>
         <div class='col-md-12'>
           <%= form_for(@article, :html => {class: "form-horizontal", role: "form"}) do |f| %>
             <div class='form-group'>
               <div class='control-label col-md-1'>
                 <%= f.label :title %>
               </div>
               <div class='col-md-11'>
                 <%= f.text_field :title, class: 'form-control', placeholder: 'Title of article', autofocus: true %>
               </div>
             </div>
             <div class='form-group'>
               <div class='control-label col-md-1'>
                 <%= f.label :body %>
               </div>
               <div class='col-md-11'>
                 <%= f.text_area :body, rows: 10, class: 'form-control', placeholder: 'Body of article' %>
               </div>
             </div>
             <div class='form-group'>
               <div class='col-md-offset-1 col-md-11'>
                 <%= f.submit class: 'btn btn-primary btn-lg pull-right' %>
               </div>
             </div>
           <% end %>
         </div>
       </div>
       ========================================================================================================

       f. Run the test, it will show the following error
          Failure/Error: click_button "Create Article"
          AbstractController::ActionNotFound:
          The action 'create' could not be found for ArticlesController

       g. Create article action
         def create
           @article = Article.new(article_params)
           @article.save
           flash[:success] = "Article has been created"
           redirect_to articles_path
         end

         private
         def article_params
           params.require(:article).permit :title, :body
         end
       run the test, it will pass the test for creating an article

Lets recap what we did with create article spec
require "rails_helper"

RSpec.feature "Creating Articles" do
  scenario "A user creates a new article" do
    visit "/"

    click_link "New Article"

    fill_in "Title", with: "Creating first article"
    fill_in "Body", with: "Lorem Ispum"
    click_button "Create Article"

    expect(page).to have_content("Article has been created")
    expect(page.current_path).to eq(articles_path)
  end
end

=================================================================================================

Step 5: Add guard to the application
        a. Guard allows us to automatically run specs when we update files. We don't have to keep issuing rspec command
        b. To add guard to the app, add
          gem "guard-rspec"
          gem 'spring-commands-rspec'

        Like as follows
          group :development, :test do
            gem 'byebug'
            gem "rspec-rails", "3.2.3"
            gem "guard-rspec"
            gem 'spring-commands-rspec'
          end

Then run the command
   => guard init rspec
  will create a Guardfile in the root directory
** Observe the Guardfile
guard :rspec, cmd: "bundle exec rspec" do
  require "guard/rspec/dsl"
  dsl = Guard::RSpec::Dsl.new(self)

Change it to the following, so that we can just type

  guard :rspec, cmd: "rspec" do
    require "guard/rspec/dsl"
    dsl = Guard::RSpec::Dsl.new(self)

** To run the guard, enter the command "guard" and heat enter. To exit guard
   enter "exit" command and heat enter


==========================================================================================================


Step 6: Validation test to article model

       a. I want to create a scenario when an article fails to save and to do this go to the spec/features/creating_article_spec.rb
       and add the following codes

       scenario "A user fails to create a new article" do
           visit "/"

           click_link "New Article"

           fill_in "Title", with: ""
           fill_in "Body", with: ""
           click_button "Create Article"

           expect(page).to have_content("Article has not been created")
           expect(page).to have_content("Title can't be blank")
           expect(page).to have_content("Body can't be blank")
         end

** Run the test, it will show
Failure/Error: expect(page).to have_content("Article has not been created")
       expected to find text "Article has not been created" in "RSpec Test App Authors × Article has been created Create a new Article New Article"

** To fix this add the failure message to the create action like as follows
def create
    @article = Article.new(article_params)
    if @article.save
      flash[:success] = "Article has been created"
      redirect_to articles_path
    else
      flash[:danger] = "Article has not been created"
      render :new
    end
  end


Still it will show the same error. Because we hadn't implemented the validation yet
** After implementing the validation, it will not pass the test, because we have not implemented the error messages as a content in the UI.
    show the error messages in the view.
   Hence to implement this
   <% if @article.errors.any? %>
     <div class="row">
       <div class="col-xs-8 col-xs-offset-2">
         <div class="panel panel-danger">
           <div class="panel-heading">
             <h2 class="panel-title">
               <%= pluralize(@article.errors.count, "error")%>
               prohibited this from being saved.
             </h2>
             <div class="panel-body">
               <ul>
                 <% @article.errors.full_messages.each do |msg| %>
                   <li><%= msg %></li>
                 <% end %>
               </ul>
             </div>
           </div>
         </div>
       </div>
     </div>
   <% end %>

   After this it will pass the test

==========================================================================================

Flash[:notice]’s message will persist to the next action and should be used when redirecting to another
 action via the ‘redirect_to’ method. Flash.now[:notice]’s message will be displayed in the view your are
  rendering via the ‘render’ method.


Step 7: Listing Articles with BDD

       a. Create an spec/features/listing_articles_spec.rb
       b. add the codes to test, run the guard

       require "rails_helper"

       RSpec.feature "Listing Articles" do

         before do
           @article1 = Article.create(title:"Title of the first article", body:"Body of the first article")
           @article2 = Article.create(title:"Title of the first article", body:"Body of the first article")
         end

         scenario "List all articles" do
           visit "/"

           expect(page).to have_content(@article1.title)
           expect(page).to have_content(@article1.body)
           expect(page).to have_content(@article1.title)
           expect(page).to have_content(@article1.body)
           expect(page).to have_link(@article1.title)
           expect(page).to have_link(@article2.title)
         end
       end

=================================================================================================

Before and after hooks

As a developer using RSpec
I want to execute arbitrary code before and after each example
So that I can control the environment in which it is run

This is supported by the before and after methods which each take a symbol
indicating the scope, and a block of code to execute.

before(:each) blocks are run before each example
before(:all) blocks are run once before all of the examples in a group

after(:each) blocks are run after each example
after(:all) blocks are run once after all of the examples in a group

Before and after blocks are called in the following order:
before suite
before all
before each
after each
after all
after suite

=================================================================================================



Now it will show the following error, because the article title and body we created in the before do block is not present
in the UI.
     1) Listing Articles List all articles
     Failure/Error: expect(page).to have_content(@article1.title)
     expected to find text "Title of the first article" in "RSpec Test App Authors Create a new Article New Article"

** To fix this, add the title and body to the index page
      <% @articles.each do |article| %>
        <div class="well well-lg">
          <div class="article-title">
            <%= article.title %>
          </div>
          <div class="article-body">
            <%= article.body %>
          </div>
        </div>
      <% end %>
Now it will show
     Failure/Error: visit "/"
     ActionView::Template::Error:
     undefined method `each' for nil:NilClass

** To fix this, define the @articles in the index action
  def index
    @articles = Article.all
  end

Now it will show
       Failure/Error: expect(page).to have_link(@article1.title)
       expected to find link "Title of the first article" but there were no matches

** To fix this, give the link to the title

================================================================================================================

Step 8: Feature test for show an article
       a. Create a spec spec/features/showing_article_spec.rb
       b. add the codes

       require "rails_helper"

       RSpec.feature "Showing an Article" do
         before do
           @article = Article.create(title:"Title of the article", body:"Body of the article")
         end

         scenario "Display individual article" do
           visit "/"   # visit root route

           click_link @article.title

           expect(page).to have_content(@article.title)
           expect(page).to have_content(@article.body)
           expect(current_path).to eql(article_path(@article))
         end
       end

---------------------------------------------------------------------------------------------
Here expect(current_path).to eql(article_path(@article))
** current_path is a capybara method to get the current path(url)
Equality matchers
Ruby exposes several different methods for handling equality:
a.equal?(b) # object identity - a and b refer to the same object
a.eql?(b)   # object equivalence - a and b have the same value
a == b      # object equivalence - a and b have the same value with type conversions


Note that these descriptions are guidelines but are not forced by the language. Any object
can implement any of these methods with its own semantics.
rspec-expectations ships with matchers that align with each of these methods:
 expect(a).to equal(b) # passes if a.equal?(b)
  expect(a).to eql(b)   # passes if a.eql?(b)
  expect(a).to be == b  # passes if a == b


It also ships with two matchers that have more of a DSL feel to them:
 expect(a).to be(b) # passes if a.equal?(b)
  expect(a).to eq(b) # passes if a == b


#Ex:
expect(current_path).to eql(article_path(@article))

-------------------------------------------------------------------------------------------------------

Run the test, it will show

     Failure/Error: click_link @article.title
     AbstractController::ActionNotFound:
     The action 'show' could not be found for ArticlesController

**To fix this create show action in the article controller
  def show
    @article = Article.find params[:id]

  end
Now run guard, and it will show, because we don't have the show templete
      Failure/Error: click_link @article.title
      ActionView::MissingTemplate:
      Missing template articles/show, application/show with {:locale=>[:en], :formats=>[:html], :variants=>[],
        :handlers=>[:erb, :builder, :raw, :ruby, :coffee, :jbuilder]}. Searched in:

**Add the show.html.erb, run the test
       Failure/Error: expect(page).to have_content(@article.title)
       expected to find text "Title of the article" in "RSpec Test App Authors"

** Add the title and body to the show page
        <article class="detail-article">
          <h1 class="article-detail-title"><%= @article.title %></h1>
          <div class="glyphicon glyphicon-calendar" id="article-date">
            <%= @article.created_at.strftime("%b %d, %Y") %>
          </div>
          <div class="article-body">
            <%= @article.body %>
          </div>
        </article>

**

=======================================================================================================

Step 9: Update the guard:
        ** I would like that to be such that, my guard file should run every time when I make a change to
        my model, controller, views or in route, my guard should run spec/fearures. To do this I have to make
        change to my guard file in the such way

       a.  # for the rails files add this lines
         watch(%r{^app/controller/(.+)_(controller)\.rb$}){"spec/features"}
         watch(%r{^app/models(.+)\.rb$}){"spec/features"}

       b. #for the Rails config changes
       watch(rails.routes)         { "#{rspec.spec_dir}/routing" }

        change this line to
        watch(rails.routes)          { "spec"} #{ "#{rspec.spec_dir}/routing" }

        c. # Capybara features specs (for the view)
        watch(rails.view_dirs)      { |m| rspec.spec.("features/#{m[1]}") }

        Change this line to
         watch(rails.view_dirs)     {"spec/features"} # { |m| rspec.spec.("features/#{m[1]}") }


** Now guard will run spec/features, when I make any changes to the desired file(model, controller, route, views)

===================================================================================================

Step 10: Edit article feature spec
         a. Create spec/features/editing_article_spec.rb
         b. Add the codes

          require "rails_helper"

          RSpec.feature "Editing an article" do

            before do
              @article = Article.create(title:"Title of the article", body:"Body of the article")
            end

            scenario "A user updates an article" do
              visit "/"

              click_link @article.title
              click_link "Edit Article"

              fill_in "Title", with: "Updated title"
              fill_in "Body", with: "Updated body"
              click_button "Update article"

              expect(page).to have_content("Article updated")
              expect(current_path).to eq(article_path(@article))

            end

            scenario "A user fail to update an article" do
              visit "/"

              click_link @article.title
              click_link "Edit Article"

              fill_in "Title", with: ""
              fill_in "Body", with: "Updated body"
              click_button "Update article"

              expect(page).to have_content("Article not updated")
              expect(current_path).to eq(article_path(@article))

            end
          end

Run guard. It will shows the error, because we don't have a link with the text "Edit Article"

         Failure/Error: click_link "Edit Article"
         Capybara::ElementNotFound:
         Unable to find link "Edit Article"

** To fix this, create a link in the show.html.erb
        <%= link_to "Edit Article", edit_article_path(@article) %>
Now the error is
        Failure/Error: click_link "Edit Article"
        AbstractController::ActionNotFound:
        The action 'edit' could not be found for ArticlesController

** To fix this create edit action in the article controller
        def edit
          @article = Article.find params[:id]
        end

Now the error is
Failure/Error: click_link "Edit Article"
       ActionView::MissingTemplate:
       Missing template articles/edit, application/edit with {:locale=>[:en], :formats=>[:html],
        :variants=>[], :handlers=>[:erb, :builder, :raw, :ruby, :coffee, :jbuilder]}. Searched

**To fix this, create edit templete(copy and paste from new.html.erb)
         Failure/Error: click_button "Update article"
         AbstractController::ActionNotFound:
         The action 'update' could not be found for ArticlesController
** Create update action in the article controller
       def update
         @article = Article.find params[:id]
         if @article.update article_params
           flash[:success] = "Article updated"
           redirect_to @article
         else
           flash.now[:notice] = "Article not updated"
           render :edit
         end
       end

Note: It now passes the test.


